# MCP Hybrid Database Schema Architecture

**Document ID:** `DB-ARCH-V1.0`
**Date:** 6/19/2025
**Author:** Principal Systems Architect
**Status:** Approved for Implementation

### **1. Architectural Overview**

This document outlines the comprehensive database schema for the Model Context Protocol (MCP) server, implementing the recommended hybrid architecture of **PostgreSQL** for structured, relational data and **ChromaDB** for high-performance semantic vector search.

The schema is organized into four distinct but interconnected memory layers, designed to provide a robust and multi-faceted memory system for the AI agent.

- **PostgreSQL** will serve as the system of record for all structured data, ensuring ACID compliance, referential integrity, and powerful querying capabilities for hierarchical and relational information.
- **ChromaDB** will store vector embeddings of textual content, enabling sophisticated semantic search and Retrieval-Augmented Generation (RAG) across documentation, guides, and codebase context.

All primary keys in PostgreSQL are of type `UUID` to ensure global uniqueness and simplify distributed system integration. Timestamps are `TIMESTAMPTZ` to maintain timezone awareness.

---

### **2. Code Memory Schema (PostgreSQL)**

This layer provides a structured, hierarchical representation of the project's codebase, including AI-generated summaries and identified dependencies.

#### **2.1. Analysis**

The goal is to model a file system tree within the relational database, associate it with AI-generated insights, and track its state over time. A self-referencing `code_files` table is the core of this design, allowing for an infinitely deep directory structure. A separate join table, `code_dependencies`, captures the explicit relationships between files (e.g., imports/exports), which is crucial for dependency analysis.

#### **2.2. PostgreSQL DDL**

##### **Enumerations**
```sql
CREATE TYPE sync_status AS ENUM ('pending', 'synced', 'error', 'stale');
```

##### **Tables**
```sql
-- Represents a top-level code repository to namespace files.
CREATE TABLE code_repositories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL UNIQUE,
    local_path TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Stores files and directories in a hierarchical structure.
CREATE TABLE code_files (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    repository_id UUID NOT NULL REFERENCES code_repositories(id) ON DELETE CASCADE,
    parent_id UUID REFERENCES code_files(id) ON DELETE CASCADE, -- Self-reference for directory hierarchy
    is_directory BOOLEAN NOT NULL DEFAULT FALSE,
    file_path TEXT NOT NULL, -- Full path relative to the repository root
    content_hash VARCHAR(64), -- SHA-256 hash of file content to detect changes
    status sync_status NOT NULL DEFAULT 'pending',
    last_analyzed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT uq_repo_filepath UNIQUE (repository_id, file_path)
);

-- Stores summaries or analyses generated by the Gemini agent for a specific file.
CREATE TABLE code_summaries (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    file_id UUID NOT NULL REFERENCES code_files(id) ON DELETE CASCADE,
    summary_text TEXT NOT NULL,
    generating_model VARCHAR(100), -- e.g., 'gemini-2.0-flash'
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- A join table to represent dependencies between code files (e.g., import statements).
CREATE TABLE code_dependencies (
    source_file_id UUID NOT NULL REFERENCES code_files(id) ON DELETE CASCADE,
    target_file_id UUID NOT NULL REFERENCES code_files(id) ON DELETE CASCADE,
    PRIMARY KEY (source_file_id, target_file_id)
);
```

#### **2.3. Indexes**
```sql
-- Index for efficiently querying files by path.
CREATE INDEX idx_code_files_path ON code_files(file_path);

-- Index for finding children of a directory.
CREATE INDEX idx_code_files_parent_id ON code_files(parent_id);

-- Indexes for optimizing dependency lookups.
CREATE INDEX idx_code_dependencies_source ON code_dependencies(source_file_id);
CREATE INDEX idx_code_dependencies_target ON code_dependencies(target_file_id);
```

---

### **3. Guides & Implementation Memory Schema (Hybrid)**

This layer captures knowledge from external documentation and synthesizes it into actionable guides linked directly to project tasks. It uses PostgreSQL for metadata and ChromaDB for semantic search.

#### **3.1. Analysis**

The core challenge is linking unstructured source material to structured, synthesized knowledge. The PostgreSQL schema establishes this chain: `source_documents` -> `document_chunks` -> `guide_chunk_map` -> `synthesized_guides`. The `synthesized_guides` are then linked to the `tasks` table. This provides full traceability from a project task back to the original source text. ChromaDB mirrors this by storing embeddings for both raw chunks and synthesized guides, enabling semantic discovery at both levels of abstraction.

#### **3.2. PostgreSQL DDL**
```sql
-- Metadata for a source of information, e.g., a documentation website or a git repository.
CREATE TABLE source_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    source_url TEXT,
    repo_context TEXT, -- Context about the source, e.g., library name
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Stores discrete chunks of text extracted from a source document.
CREATE TABLE document_chunks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    source_document_id UUID NOT NULL REFERENCES source_documents(id) ON DELETE CASCADE,
    chunk_text TEXT NOT NULL,
    metadata JSONB, -- For extra context like page number, section header, etc.
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Stores synthesized, project-specific guides created from one or more document chunks.
CREATE TABLE synthesized_guides (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID REFERENCES tasks(id) ON DELETE SET NULL, -- Link to a specific project task
    title VARCHAR(512) NOT NULL,
    content TEXT NOT NULL, -- The synthesized, actionable guide
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Many-to-many relationship linking synthesized guides to the chunks they were derived from.
CREATE TABLE guide_chunk_map (
    guide_id UUID NOT NULL REFERENCES synthesized_guides(id) ON DELETE CASCADE,
    chunk_id UUID NOT NULL REFERENCES document_chunks(id) ON DELETE CASCADE,
    PRIMARY KEY (guide_id, chunk_id)
);
```

#### **3.3. ChromaDB Collection Schema**

*   **Collection Name:** `guides_and_chunks_collection`
*   **Purpose:** To enable semantic search over both raw knowledge chunks and refined, synthesized guides.

| Metadata Field | Data Type | Description | Example |
| :--- | :--- | :--- | :--- |
| `reference_id` | String (UUID) | The primary key from the corresponding PostgreSQL table (`document_chunks.id` or `synthesized_guides.id`). **Required for linking.** | `"a1b2c3d4-..."` |
| `reference_type` | String | Specifies whether the vector represents a raw chunk or a synthesized guide. **Required for filtering.** | `"chunk"` or `"guide"` |
| `source_document_id`| String (UUID) | The ID of the parent `source_documents` entry. Only present for `reference_type: 'chunk'`. | `"e5f6g7h8-..."` |
| `task_id` | String (UUID) | The ID of the associated `tasks` entry. Only present for `reference_type: 'guide'`. | `"i9j0k1l2-..."` |

---

### **4. Task Memory Schema (PostgreSQL)**

This layer provides a robust relational structure for project management, including a grand plan, hierarchical tasks, dependencies, and conflict logging.

#### **4.1. Analysis**

Effective task management requires a clear hierarchy (`parent_task_id`), dependency tracking (`task_dependencies`), and categorization (`feature_classification`). This schema provides these core features. By defining `task_status` as an `ENUM`, we enforce a consistent state machine for tasks. The `build_conflicts` table serves as a dedicated log for deviations or issues encountered during development, linking them back to specific tasks for context.

#### **4.2. PostgreSQL DDL**

##### **Enumerations**
```sql
CREATE TYPE task_status_enum AS ENUM ('pending', 'in_progress', 'blocked', 'review', 'done', 'archived');
```

##### **Tables**
```sql
-- Represents a high-level project objective or epic.
CREATE TABLE grand_plans (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    objective TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- The core table for managing tasks and sub-tasks.
CREATE TABLE tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    grand_plan_id UUID NOT NULL REFERENCES grand_plans(id) ON DELETE CASCADE,
    parent_task_id UUID REFERENCES tasks(id) ON DELETE CASCADE, -- For sub-task hierarchy
    title VARCHAR(512) NOT NULL,
    description TEXT,
    status task_status_enum NOT NULL DEFAULT 'pending',
    priority INTEGER DEFAULT 0,
    feature_classification VARCHAR(100), -- e.g., 'frontend', 'backend', 'auth'
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Join table for many-to-many task dependencies (e.g., Task A must be completed before Task B).
CREATE TABLE task_dependencies (
    task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
    depends_on_task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
    PRIMARY KEY (task_id, depends_on_task_id)
);

-- Join table to associate tasks with specific code files.
CREATE TABLE task_code_files (
    task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
    code_file_id UUID NOT NULL REFERENCES code_files(id) ON DELETE CASCADE,
    PRIMARY KEY (task_id, code_file_id)
);

-- Logs conflicts or deviations from the grand plan identified during build/execution flows.
CREATE TABLE build_conflicts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_id UUID REFERENCES tasks(id) ON DELETE SET NULL, -- The task associated with the conflict
    description TEXT NOT NULL,
    is_resolved BOOLEAN NOT NULL DEFAULT FALSE,
    resolved_at TIMESTAMPTZ,
    logged_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

#### **4.3. Indexes**
```sql
-- Index for finding sub-tasks.
CREATE INDEX idx_tasks_parent_task_id ON tasks(parent_task_id);

-- Index for querying tasks by status or classification.
CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_tasks_feature_classification ON tasks(feature_classification);
```

---

### **5. Dependency Memory Schema (Hybrid)**

This layer tracks external project dependencies (libraries, frameworks) and provides a semantically searchable knowledge base of their documentation.

#### **5.1. Analysis**

The schema separates the *what* from the *how*. PostgreSQL's `project_dependencies` table catalogs *what* dependencies are used, their versions, and where their official documentation resides. This is factual, structured data. ChromaDB then stores embeddings of the documentation itself, answering the *how*. The metadata in ChromaDB is critical, linking each piece of documentation back to the specific library (`dependency_id`) and the project feature it is relevant to (`feature_relation`), enabling highly contextual semantic searches.

#### **5.2. PostgreSQL DDL**
```sql
-- Enumeration for package managers.
CREATE TYPE dependency_manager_enum AS ENUM ('npm', 'pip', 'maven', 'go', 'cargo', 'other');

-- Stores information about project dependencies like libraries and frameworks.
CREATE TABLE project_dependencies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    version VARCHAR(50) NOT NULL,
    manager dependency_manager_enum NOT NULL,
    documentation_url TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT uq_dependency_name_version UNIQUE (name, version, manager)
);
```

#### **5.3. ChromaDB Collection Schema**

*   **Collection Name:** `dependency_docs_collection`
*   **Purpose:** To provide a semantically searchable knowledge base of dependency documentation.

| Metadata Field | Data Type | Description | Example |
| :--- | :--- | :--- | :--- |
| `dependency_id` | String (UUID) | The primary key from the `project_dependencies` table in PostgreSQL. **Required for linking.** | `"f0e1d2c3-..."` |
| `feature_relation` | String | A tag describing which project feature or development stage this documentation chunk is relevant to. | `"user-authentication"` |
| `source_section` | String | The specific section or page of the documentation this chunk was extracted from. | `"API Reference: create_user"` |
| `dependency_name` | String | The human-readable name of the dependency for easier filtering and context. | `"react-router-dom"` |